(B) Remove com.apple.developer.aps-environment from LockOut-macOS.entitlements; this entitlement is only valid for App Store or MDM-provisioned apps and causes notarytool rejection for Developer ID builds +infra
(B) Add com.apple.security.hardened-runtime: true to LockOut-macOS.entitlements in project.yml entitlements properties block to satisfy Gatekeeper requirements for Developer ID notarization +infra
(B) Add com.apple.security.cs.allow-unsigned-executable-memory: false and com.apple.security.cs.disable-library-validation: false to LockOut-macOS.entitlements (notarytool requires these to be explicit or absent; setting false documents intent) +infra
(B) Update project.yml macOS target base settings to add CODE_SIGN_IDENTITY: "Developer ID Application" and CODE_SIGN_STYLE: Manual and DEVELOPMENT_TEAM: "" placeholder for Developer ID signing outside the App Store +infra
(B) Add Sparkle as a remote Swift package in project.yml under packages: with key Sparkle, url: https://github.com/sparkle-project/Sparkle, from: "2.6.0" +infra
(B) Add package: Sparkle product: Sparkle to the LockOut-macOS target dependencies list in project.yml so the framework links into the macOS target +infra
(B) Create LockOut-macOS/UpdaterController.swift with final class UpdaterController containing let updater = SPUStandardUpdaterController(startingUpdater: true, updaterDelegate: nil, userDriverDelegate: nil) as a lazy property so Sparkle initializes on first access +infra
(B) Add private(set) var updaterController: UpdaterController! to AppDelegate and initialize it as updaterController = UpdaterController() in applicationDidFinishLaunching before starting the scheduler +infra
(B) Add "Check for Updatesâ€¦" NSMenuItem in MenuBarController.buildMenu() in the separator block before "Quit LockOut" with target AppDelegate.shared.updaterController.updater and action #selector(SPUUpdater.checkForUpdates(_:)) +infra
(B) Add SUFeedURL String info property in project.yml under targets.LockOut-macOS.info.properties with value "https://your-domain.com/appcast.xml" as the Sparkle update feed placeholder to replace before distribution +infra
(B) Add SUPublicEDKey String info property in project.yml under targets.LockOut-macOS.info.properties with empty string placeholder for the Sparkle EdDSA public key; generate the real key pair with Sparkle's generate_keys CLI tool and substitute before shipping +infra
(B) Create scripts/export-options.plist with keys: method=developer-id, signingStyle=manual, teamID=YOURTEAMID, stripSwiftSymbols=true, compileBitcode=false for use with xcodebuild -exportArchive; replace YOURTEAMID with actual 10-character Apple team ID +infra
(B) Create scripts/build-dmg.sh with set -euo pipefail; xcodebuild clean archive -scheme LockOut-macOS -archivePath build/LockOut.xcarchive; xcodebuild -exportArchive -archivePath build/LockOut.xcarchive -exportPath build/ -exportOptionsPlist scripts/export-options.plist; create-dmg --volname "LockOut" --window-size 540 380 --icon-size 128 --app-drop-link 380 185 dist/LockOut.dmg "build/LockOut.app" +infra
(B) Create Makefile at repo root with targets: build (sh scripts/build-dmg.sh), test (swift test --package-path Packages/LockOutCore), clean (rm -rf build/ dist/), and notarize (xcrun notarytool submit dist/LockOut.dmg --keychain-profile AC_PASSWORD --wait) +infra
(B) Add a scheme definition for LockOut-macOS in project.yml under schemes: so xcodebuild -scheme LockOut-macOS resolves correctly during archive without requiring Xcode to be open +infra
(B) Call SettingsSyncService.stopObserving() inside AppDelegate.applicationWillTerminate to remove the NSUbiquitousKeyValueStoreDidChangeExternallyNotification observer and prevent a crash if the store fires after the app has begun tearing down +stability
(B) Add guard windows.isEmpty else { return } at the top of BreakOverlayWindowController.show() to prevent stacking a second overlay set if show() is called while an overlay is already visible +stability +macos
(B) Add NSWorkspace.shared.notificationCenter addObserver for NSWorkspace.willSleepNotification in AppDelegate.applicationDidFinishLaunching calling scheduler.pause() so timers stop and no overlay fires during machine sleep +stability +macos
(B) Add NSWorkspace.shared.notificationCenter addObserver for NSWorkspace.didWakeNotification in AppDelegate.applicationDidFinishLaunching calling scheduler.resume() so scheduling restarts automatically after wake without requiring a relaunch +stability +macos
(B) Add NSWorkspace.shared.notificationCenter addObserver for NSWorkspace.screensDidSleepNotification calling overlayController?.dismiss() so any active overlay is cleared before the display sleeps and does not appear as a frozen frame on wake +stability +macos
(B) Fix DashboardView.todayCompliance to call repository.fetchSessions(from: Calendar.current.startOfDay(for: Date()), to: Date()) and compute rate as Double(sessions.filter { $0.status == .completed }.count) / Double(max(sessions.count, 1)) instead of relying on dailyStats(for: 1).first which may return yesterday's row near midnight +stability +macos
(B) Add @Published var syncError: String? to AppDelegate; assign a non-nil value from a CloudKitSyncService error callback when CKError is not networkUnavailable; in SettingsView show Text(error).foregroundStyle(.red).font(.caption) below the Sync button when syncError != nil +stability +macos
(B) Write XCTest for BreakHistoryRepository save idempotency: insert two BreakSessions with identical UUID but different status (.skipped then .completed), fetch all, assert count == 1 and status == .completed +test
(B) Write XCTest for AppSettingsStore round-trip: call AppSettingsStore.save(.defaults), then AppSettingsStore.load() and assert the loaded value is non-nil and all three intervalMinutes values match .defaults +test
(B) Write XCTest for BreakScheduler multi-timer: call start(settings: .defaults), assert timers.count == 3 (one per enabled break type) after start() +test
