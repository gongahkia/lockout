(B) Move `pruneOldRecords()` call in `AppDelegate.applicationDidFinishLaunching` to a detached `Task` so it does not block the main thread at launch +stability
(B) Add error handling in `BreakHistoryRepository.pruneOldRecords()`: wrap SwiftData delete in do/catch; write errors to stderr via fputs +stability
(B) Debounce `reschedule()` calls triggered by ScheduleView stepper/slider changes by 500ms using Combine `.debounce(for: .milliseconds(500), scheduler: RunLoop.main)` +stability
(B) Check `UNUserNotificationCenter.current().getNotificationSettings` authorization status before calling `.add(_:)` anywhere; skip silently if not authorized +stability
(B) Update streak badge immediately after `markCompleted()` returns in BreakScheduler by calling `MenuBarController.updateStreak()` directly instead of waiting for next 60s tick +ux
(B) Add 100ms debounce on `NSWorkspace.didActivateApplicationNotification` handler before calling `frontmostAppIsFullscreen()` to mitigate CGWindowList race condition +stability
(B) Move `frontmostAppIsFullscreen()` and `isScreenLocked()` out of BreakOverlayWindowController into a `SystemStateService` class in LockOutCore for unit testability +refactor
(B) Remove all `AppDelegate.shared` references from BreakOverlayWindowController; inject `scheduler` and `repository` via init parameters instead +refactor
(B) Remove all `AppDelegate.shared` references from MenuBarController; inject `scheduler`, `repository`, and `settingsSync` via init parameters instead +refactor
(B) Add SwiftData schema migration stubs: define `LockOutSchemaMigrationPlan` conforming to SchemaMigrationPlan in AppDelegate; pass to ModelConfiguration so future model changes do not crash on upgrade +stability
(B) Create `Config.xcconfig` (git-ignored) with keys: PRODUCT_BUNDLE_IDENTIFIER, DEVELOPMENT_TEAM, CLOUDKIT_CONTAINER_ID, SPARKLE_FEED_URL, SPARKLE_ED_KEY; create committed `Config.xcconfig.template` with placeholder values +infra +config
(B) Add `make setup-config` target in Makefile: copies Config.xcconfig.template to Config.xcconfig if Config.xcconfig does not already exist +infra +config
(B) Update project.yml to read DEVELOPMENT_TEAM and PRODUCT_BUNDLE_IDENTIFIER from xcconfig variables $(DEVELOPMENT_TEAM) and $(PRODUCT_BUNDLE_IDENTIFIER) +infra +config
(B) Replace hardcoded `iCloud.com.yourapp.lockout` string in CloudKitSyncService.swift with `Bundle.main.object(forInfoDictionaryKey: "CLOUDKIT_CONTAINER_ID") as? String` +infra +config
(B) Add CLOUDKIT_CONTAINER_ID, SPARKLE_FEED_URL, SPARKLE_ED_KEY Info.plist keys in project.yml that expand from xcconfig variables +infra +config
(B) Update Info.plist SUFeedURL and SUPublicEDKey entries to use $(SPARKLE_FEED_URL) and $(SPARKLE_ED_KEY) xcconfig variable expansion +infra +config
(B) Add launch-time guard in AppDelegate: if PRODUCT_BUNDLE_IDENTIFIER == "com.yourapp.lockout" show NSAlert "Configure Config.xcconfig before distributing" and terminate +infra +config
(B) Move Makefile `notarize` target body behind `ifeq ($(NOTARIZE),1)` guard to prevent accidental notarization +infra
(B) Add `NetworkMonitor` class to LockOutCore wrapping `NWPathMonitor`; publish `isConnected: Bool` on main queue; expose as `NetworkMonitor.shared` +cloudkit +offline-first
(B) Gate all CloudKit `CKDatabase.add(_:)` calls in CloudKitSyncService behind `NetworkMonitor.shared.isConnected`; enqueue failed ops to `pendingUploads` when offline +cloudkit +offline-first
(B) Add `pendingUploads: [BreakSessionRecord]` in CloudKitSyncService serialized as JSON via JSONEncoder into UserDefaults key `ckPendingUploads`; restore queue on init +cloudkit +offline-first
(B) Implement exponential backoff retry in CloudKitSyncService: on CKError.serverRecordChanged or networkFailure retry after 2s, 4s, 8s delays up to 3 attempts before moving to pendingUploads +cloudkit +offline-first
(B) Observe `NetworkMonitor.shared.$isConnected` in CloudKitSyncService via Combine sink; on transition to true flush entire `pendingUploads` queue in order +cloudkit +offline-first
(B) Add CloudKit sync status row in StatisticsView: "Last synced: <formatted date>" label and warning icon badge when `pendingUploads.count > 0` +ux
(B) Add `CustomBreakType: Codable, Identifiable, Equatable` struct to Models.swift with fields: id (UUID), name (String), intervalMinutes (Int), durationSeconds (Int), minDisplaySeconds (Int), enabled (Bool), soundName (String?), message (String?), tips ([String]), overlayOpacity (Double), overlayColorHex (String), snoozeMinutes (Int) +feature +custom-breaks
(B) Add `customBreakTypes: [CustomBreakType]` to AppSettings struct with three default entries matching existing Eye/Micro/Long break constants so existing behaviour is preserved +feature +custom-breaks
(B) Update BreakScheduler to iterate `settings.customBreakTypes.filter(\.enabled)` when creating timer entries; remove references to fixed BreakType enum for scheduling +feature +custom-breaks
(B) Update `BreakSessionRecord` model and `BreakHistoryRepository.save()` to store `breakTypeName: String` in place of BreakType enum so custom type names persist correctly +feature +custom-breaks
(B) Add `CustomBreakTypeEditorView` as a sheet in ScheduleView: text field for name, steppers for interval/duration/minDisplay/snooze, sound picker, message text field, tips list editor, opacity slider, color picker, enabled toggle +feature +custom-breaks
(B) Add add/delete/reorder controls for custom break types in ScheduleView: List with `.onDelete` and `.onMove` bound to `settings.customBreakTypes` +feature +custom-breaks
(B) Validate CustomBreakType in editor before save: intervalMinutes >= 1, durationSeconds >= 10, minDisplaySeconds <= durationSeconds; show inline error Text if invalid +stability +feature
(B) Enforce `minDisplaySeconds` in BreakOverlayWindowController: record `showTime = Date()` on show; disable skip/snooze button until `Date().timeIntervalSince(showTime) >= Double(breakType.minDisplaySeconds)` +feature
(B) Replace global snooze constant in BreakScheduler with `currentBreakType.snoozeMinutes` so snooze duration is per-break-type +feature +configurable
(B) Add `blockedBundleIDs: [String]` to AppSettings; in BreakOverlayWindowController.shouldShow() auto-complete break without showing overlay when frontmost app bundle ID is in blocklist +feature +configurable
(B) Add blocklist editor section in SettingsView: list currently running apps (NSRunningApplication.runningApplications) as toggles plus manual text field for unlisted bundle IDs +feature +configurable
(B) Implement idle/AFK detection Timer in AppDelegate firing every 30s: call `CGEventSourceSecondsSinceLastEventType(.combinedSessionState, .null)`; if >= idleThresholdMinutes*60 call `scheduler.pause()` +feature +configurable
(B) Add `idleThresholdMinutes: Int` (default 5, range 1–60) to AppSettings; expose as stepper in SettingsView under "Auto-Pause" section +feature +configurable
(B) Auto-resume after idle pause: install `NSEvent.addGlobalMonitorForEvents(matching: [.mouseMoved, .keyDown])` after idle pause fires; call `scheduler.resume()` on first event and remove monitor +feature
(B) Add `pauseDuringFocus: Bool` to AppSettings (default false); observe `com.apple.donotdisturb.state.changed` Darwin notification in AppDelegate; pause/resume scheduler when Focus state changes +feature +configurable
(B) Add `pauseDuringCalendarEvents: Bool` to AppSettings (default false); request EKEventStore access only when enabled; poll upcoming events every 60s; pause scheduler if an event is active +feature +configurable
(B) Add `workdayEndTime: DateComponents?` to AppSettings; in AppDelegate schedule a daily Calendar-based Timer that fires at that time and calls `scheduler.pause()` +feature +configurable
(B) Add `workdayStartTime: DateComponents?` to AppSettings; in AppDelegate schedule a daily Calendar-based Timer that fires at that time and calls `scheduler.resume()` +feature +configurable
(B) Add configurable workday start/end time pickers in SettingsView bound to `settings.workdayStartTime` and `settings.workdayEndTime` +feature +configurable
(B) Add `AppProfile: Codable, Identifiable` struct with fields id (UUID), name (String), customBreakTypes ([CustomBreakType]), blockedBundleIDs ([String]), idleThresholdMinutes (Int); add `profiles: [AppProfile]` and `activeProfileId: UUID` to AppSettings +feature +profiles
(B) Add profile switcher submenu in MenuBarController status menu listing all profiles by name; selecting one sets `settings.activeProfileId` and calls `scheduler.reschedule()` +feature +profiles
(B) Add ProfileEditorView accessible from SettingsView with create/rename/duplicate/delete actions for profiles +feature +profiles
(B) Add settings JSON export: encode current AppSettings via JSONEncoder; present NSSavePanel defaulting to filename `lockout-settings.json`; write data to selected URL +feature +configurable
(B) Add settings JSON import: present NSOpenPanel filtering .json; decode with JSONDecoder into AppSettings; show NSAlert listing changed keys; on confirm apply and call `scheduler.reschedule()` +feature +configurable
(B) Add "Take Break Now" NSMenuItem in MenuBarController status menu with submenu listing each enabled CustomBreakType by name; selection calls `scheduler.triggerBreak(type:)` +feature +ux
(B) Add "Next break in X:XX" NSMenuItem in MenuBarController status menu updated every tick by `tickTimer` alongside the existing icon countdown badge +ux
(B) Add break reminder UNNotificationContent with action buttons: "Start Break Now" (foreground) and "Snooze" (background, uses breakType.snoozeMinutes); handle in UNUserNotificationCenterDelegate.didReceive +feature +ux
(B) Add `notificationLeadMinutes: Int` (default 1, range 0–5) to AppSettings; schedule `UNTimeIntervalNotificationTrigger` for `intervalSeconds - leadMinutes*60` before each break; expose stepper in SettingsView +feature +configurable
(B) Schedule weekly compliance summary notification: every Monday 09:00 local time via `UNCalendarNotificationTrigger`; body contains last 7 days compliance % from `repository.dailyStats()` +feature
(B) Add `weeklyNotificationEnabled: Bool` to AppSettings (default false); expose toggle in SettingsView; schedule or cancel Monday notification on toggle change +feature +configurable
(B) Add per-break-type exercise tips: `tips: [String]` field in CustomBreakType editable in CustomBreakTypeEditorView; cycle tips every 5s in BreakOverlayView using a local Timer +feature
(B) Add overlay background color per CustomBreakType: store as hex string in `overlayColorHex`; add `Color(hex:)` extension; apply in BreakOverlayView root ZStack background +feature +configurable
(B) Add overlay blur per CustomBreakType: store `overlayBlurMaterial: String` (ultraThin/thin/medium/hudWindow); apply as NSVisualEffectView in BreakOverlayWindowController +feature +configurable
(B) Bundle three audio assets (chime.aiff, bell.aiff, silence placeholder) in LockOut-macOS/Resources; play selected sound via AVAudioPlayer in BreakOverlayWindowController.show() respecting system mute state +feature +configurable
(B) Add global snooze hotkey: store `globalSnoozeHotkey: HotkeyDescriptor?` (keyCode: Int, modifierFlags: Int, Codable) in AppSettings; register/unregister CGEventTap in AppDelegate on settings change; calls `scheduler.snooze()` +feature +configurable
(B) Add hotkey recorder control in SettingsView that captures next keypress as `HotkeyDescriptor` and writes to `settings.globalSnoozeHotkey` +feature +configurable
(B) Add `historyRetentionDays: Int` (options 30/60/90/365/0=unlimited) to AppSettings; pass to `repository.pruneOldRecords(olderThan:)` at launch and in the midnight timer +feature +configurable
(B) Add "Retention Period" picker in SettingsView with values "30 days / 60 days / 90 days / 1 year / Unlimited" bound to `settings.historyRetentionDays` +feature +configurable
(B) Add JSON export option in StatisticsView alongside existing CSV: encode `[DailyStats]` via JSONEncoder; present NSSavePanel with .json extension +feature
(B) Add per-break-type compliance columns to CSV and JSON exports from StatisticsView (one column per CustomBreakType name) +feature
(B) Add `menuBarIconTheme: MenuBarIconTheme` (enum: monochrome, color, minimal; Codable) to AppSettings; MenuBarController applies different NSImage based on active theme +feature +configurable
(B) Add "Menu Bar Icon" picker in SettingsView with monochrome/color/minimal options bound to `settings.menuBarIconTheme` +feature +configurable
(B) Add launch-at-login toggle in SettingsView bound directly to `LaunchAtLoginService`; do not remove from onboarding but ensure both stay in sync +ux
(B) Add onboarding step before `requestAuthorization` call: show explanatory text "LockOut sends a reminder before each break" with explicit "Allow Notifications" and "Skip" buttons; only call `requestAuthorization` if Allow tapped +ux
(B) Add onboarding step for optional integrations (Calendar, Focus Mode): show toggle list; request EKEventStore or DND access only for enabled items; write results to AppSettings +ux
(B) Add `AppVersion` struct to LockOutCore with static `current: String` read from `Bundle.main.infoDictionary["CFBundleShortVersionString"]`; display in SettingsView footer and "About LockOut vX.Y.Z" NSMenuItem +ux
(B) Add XCUITest target `LockOut-macOSUITests` in project.yml with host application set to LockOut-macOS +test +infra
(B) Handle `--uitesting` launch argument in AppDelegate: use `ModelConfiguration(isStoredInMemoryOnly: true)` to isolate SwiftData state during UI test runs +test +infra
(B) Add XCTest for CloudKitSyncService conflict resolution: construct two BreakSessionRecord with same UUID, statuses completed vs skipped; assert `resolveConflict` returns completed record +test
(B) Add XCTest for offline upload queue: force NetworkMonitor offline; call `cloudSync.uploadSession(record)`; assert pendingUploads.count == 1; restore online; flush; assert count == 0 +test
(B) Add XCTest for custom break type scheduling: init BreakScheduler with AppSettings.customBreakTypes containing two enabled entries; call `start()`; assert timers.count == 2 +test
(B) Add XCTest for blocklist auto-complete: init overlay controller with blocklist containing "com.test.app"; call `shouldShow(frontmostBundleID: "com.test.app")`; assert returns false +test
(B) Add XCTest for settings import/export round-trip: encode AppSettings with non-default customBreakTypes to JSON; decode; assert decoded == original +test
(B) Add XCTest for minDisplaySeconds enforcement: show overlay with minDisplaySeconds = 10; assert skip button disabled at t=0 and enabled at t=11 +test
(B) Add XCTest for idle-pause: set idleThresholdMinutes = 1; inject idle seconds = 61; call idle check handler; assert scheduler.isPaused == true +test
