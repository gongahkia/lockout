(B) Update AppDelegate.applicationDidFinishLaunching settings loading line to: let settings = settingsSync.pull() ?? AppSettingsStore.load() ?? .defaults giving the app a valid local fallback when iCloud is unavailable at first launch +persistence +macos
(B) In AppDelegate, add a Combine sink on scheduler.$currentSettings .dropFirst() .sink { AppSettingsStore.save($0) } stored in cancellables to persist any in-session mutations (pause, snooze config, toggle) locally without requiring an explicit save call +persistence +macos
(B) Create LockOut-macOS/LockOutOverlayWindow.swift defining final class LockOutOverlayWindow: NSWindow with override var canBecomeKey: Bool { true } and var onEscape: (() -> Void)? property +feature +macos
(B) Override keyDown(with event: NSEvent) in LockOutOverlayWindow to detect event.keyCode == 53 (Escape) and call onEscape?() when matched, forwarding all other events to super +feature +macos
(B) Update BreakOverlayWindowController.show() to instantiate LockOutOverlayWindow instead of NSWindow for each screen entry, set its onEscape closure to { [weak self] in self?.scheduler.skip(repository: self!.repo); self?.dismiss() }, and call win.makeKey() after win.orderFront(nil) so the overlay receives keyboard input +feature +macos
(B) Add streak count display to NSStatusItem button in MenuBarController.updateIcon(): compute streak = ComplianceCalculator.streakDays(stats: AppDelegate.shared.repository.dailyStats(for: 30)) and set statusItem.button?.title = streak > 0 ? " \(streak)" : "" so the count appears beside the eye icon +feature +macos
(B) Set statusItem.button?.imagePosition = .imageLeading when streak > 0 and .imageOnly when streak == 0 to correctly position the streak number to the right of the icon +feature +macos
(B) Recompute streak in MenuBarController.startTick() every 60 seconds (not every 1 second) by adding a separate tickCount property and calling updateStreak() only when tickCount % 60 == 0 to avoid calling dailyStats on every 1-second tick +feature +macos
(B) Remove com.apple.developer.aps-environment from LockOut-macOS.entitlements; this entitlement is only valid for App Store or MDM-provisioned apps and causes notarytool rejection for Developer ID builds +infra
(B) Add com.apple.security.hardened-runtime: true to LockOut-macOS.entitlements in project.yml entitlements properties block to satisfy Gatekeeper requirements for Developer ID notarization +infra
(B) Add com.apple.security.cs.allow-unsigned-executable-memory: false and com.apple.security.cs.disable-library-validation: false to LockOut-macOS.entitlements (notarytool requires these to be explicit or absent; setting false documents intent) +infra
(B) Update project.yml macOS target base settings to add CODE_SIGN_IDENTITY: "Developer ID Application" and CODE_SIGN_STYLE: Manual and DEVELOPMENT_TEAM: "" placeholder for Developer ID signing outside the App Store +infra
(B) Add Sparkle as a remote Swift package in project.yml under packages: with key Sparkle, url: https://github.com/sparkle-project/Sparkle, from: "2.6.0" +infra
(B) Add package: Sparkle product: Sparkle to the LockOut-macOS target dependencies list in project.yml so the framework links into the macOS target +infra
(B) Create LockOut-macOS/UpdaterController.swift with final class UpdaterController containing let updater = SPUStandardUpdaterController(startingUpdater: true, updaterDelegate: nil, userDriverDelegate: nil) as a lazy property so Sparkle initializes on first access +infra
(B) Add private(set) var updaterController: UpdaterController! to AppDelegate and initialize it as updaterController = UpdaterController() in applicationDidFinishLaunching before starting the scheduler +infra
(B) Add "Check for Updatesâ€¦" NSMenuItem in MenuBarController.buildMenu() in the separator block before "Quit LockOut" with target AppDelegate.shared.updaterController.updater and action #selector(SPUUpdater.checkForUpdates(_:)) +infra
(B) Add SUFeedURL String info property in project.yml under targets.LockOut-macOS.info.properties with value "https://your-domain.com/appcast.xml" as the Sparkle update feed placeholder to replace before distribution +infra
(B) Add SUPublicEDKey String info property in project.yml under targets.LockOut-macOS.info.properties with empty string placeholder for the Sparkle EdDSA public key; generate the real key pair with Sparkle's generate_keys CLI tool and substitute before shipping +infra
(B) Create scripts/export-options.plist with keys: method=developer-id, signingStyle=manual, teamID=YOURTEAMID, stripSwiftSymbols=true, compileBitcode=false for use with xcodebuild -exportArchive; replace YOURTEAMID with actual 10-character Apple team ID +infra
(B) Create scripts/build-dmg.sh with set -euo pipefail; xcodebuild clean archive -scheme LockOut-macOS -archivePath build/LockOut.xcarchive; xcodebuild -exportArchive -archivePath build/LockOut.xcarchive -exportPath build/ -exportOptionsPlist scripts/export-options.plist; create-dmg --volname "LockOut" --window-size 540 380 --icon-size 128 --app-drop-link 380 185 dist/LockOut.dmg "build/LockOut.app" +infra
(B) Create Makefile at repo root with targets: build (sh scripts/build-dmg.sh), test (swift test --package-path Packages/LockOutCore), clean (rm -rf build/ dist/), and notarize (xcrun notarytool submit dist/LockOut.dmg --keychain-profile AC_PASSWORD --wait) +infra
(B) Add a scheme definition for LockOut-macOS in project.yml under schemes: so xcodebuild -scheme LockOut-macOS resolves correctly during archive without requiring Xcode to be open +infra
(B) Call SettingsSyncService.stopObserving() inside AppDelegate.applicationWillTerminate to remove the NSUbiquitousKeyValueStoreDidChangeExternallyNotification observer and prevent a crash if the store fires after the app has begun tearing down +stability
(B) Add guard windows.isEmpty else { return } at the top of BreakOverlayWindowController.show() to prevent stacking a second overlay set if show() is called while an overlay is already visible +stability +macos
(B) Add NSWorkspace.shared.notificationCenter addObserver for NSWorkspace.willSleepNotification in AppDelegate.applicationDidFinishLaunching calling scheduler.pause() so timers stop and no overlay fires during machine sleep +stability +macos
(B) Add NSWorkspace.shared.notificationCenter addObserver for NSWorkspace.didWakeNotification in AppDelegate.applicationDidFinishLaunching calling scheduler.resume() so scheduling restarts automatically after wake without requiring a relaunch +stability +macos
(B) Add NSWorkspace.shared.notificationCenter addObserver for NSWorkspace.screensDidSleepNotification calling overlayController?.dismiss() so any active overlay is cleared before the display sleeps and does not appear as a frozen frame on wake +stability +macos
(B) Fix DashboardView.todayCompliance to call repository.fetchSessions(from: Calendar.current.startOfDay(for: Date()), to: Date()) and compute rate as Double(sessions.filter { $0.status == .completed }.count) / Double(max(sessions.count, 1)) instead of relying on dailyStats(for: 1).first which may return yesterday's row near midnight +stability +macos
(B) Add @Published var syncError: String? to AppDelegate; assign a non-nil value from a CloudKitSyncService error callback when CKError is not networkUnavailable; in SettingsView show Text(error).foregroundStyle(.red).font(.caption) below the Sync button when syncError != nil +stability +macos
(B) Write XCTest for BreakHistoryRepository save idempotency: insert two BreakSessions with identical UUID but different status (.skipped then .completed), fetch all, assert count == 1 and status == .completed +test
(B) Write XCTest for AppSettingsStore round-trip: call AppSettingsStore.save(.defaults), then AppSettingsStore.load() and assert the loaded value is non-nil and all three intervalMinutes values match .defaults +test
(B) Write XCTest for BreakScheduler multi-timer: call start(settings: .defaults), assert timers.count == 3 (one per enabled break type) after start() +test
