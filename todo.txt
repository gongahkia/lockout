(A) iOS: Create @main SwiftUI App struct; in init create ModelContainer for [BreakSessionRecord].self and inject as environment value +ios
(A) iOS: On init request UNAuthorizationOptions [.alert, .sound, .badge] via UNUserNotificationCenter.current().requestAuthorization and store Bool result in UserDefaults "notif_granted" +ios
(A) iOS: Implement TabView with tabs Dashboard (systemImage "house"), Schedule (systemImage "clock"), Statistics (systemImage "chart.bar"), Settings (systemImage "gear") +ios
(A) iOS DashboardView: Text showing next break type and countdown (MM:SS) updated by Timer.publish, Text showing today compliance %, three Toggle rows for break types +ios
(A) iOS ScheduleView: List with three Section headers (Eye Break, Micro Break, Long Break) each containing Stepper for interval (1...120 min) and Stepper for duration (5...3600 sec) +ios
(A) iOS StatisticsView: Swift Charts BarMark chart matching macOS design, date range Picker [7, 14, 30], summary row with total sessions / rate / streak +ios
(A) iOS SettingsView: Stepper for snooze duration, Stepper for retention days, iCloud sync status Text and "Sync Now" Button, "Request Notification Permission" Button shown if notif_granted == false +ios
(A) iOS: Implement NotificationScheduler struct with schedule(settings: AppSettings) that cancels all pending UNNotificationRequests then creates one UNNotificationRequest per enabled break type with UNTimeIntervalNotificationTrigger(timeInterval: intervalMinutes*60, repeats: true) +ios
(A) iOS NotificationScheduler: UNNotificationContent for eye break sets title "Eye Break", body "Look at something 20 feet away for 20 seconds", sound .default +ios
(A) iOS NotificationScheduler: UNNotificationContent for micro break sets title "Micro Break", body "Step away and relax for a moment", sound .default +ios
(A) iOS NotificationScheduler: UNNotificationContent for long break sets title "Long Break", body "Take a full break and breathe deeply", sound .default +ios
(A) iOS: Define UNNotificationCategory "BREAK_CATEGORY" with actions: UNNotificationAction(identifier: "SNOOZE", title: "Snooze \(n) min", options: []) and UNNotificationAction(identifier: "DONE", title: "Done", options: .foreground) +ios
(A) iOS: Register the BREAK_CATEGORY with UNUserNotificationCenter.current().setNotificationCategories() in app init +ios
(A) iOS: Implement UNUserNotificationCenterDelegate.userNotificationCenter(_:didReceive:) — on "SNOOZE" response cancel existing notification for that category and schedule new one offset by snoozeDurationMinutes; on "DONE" save completed BreakSession via BreakHistoryRepository +ios
(A) iOS: Register BGAppRefreshTask identifier "com.yourapp.lookaway.refresh" in Info.plist key BGTaskSchedulerPermittedIdentifiers +ios
(A) iOS: BGAppRefreshTask handler calls NotificationScheduler.schedule(settings:) to recalibrate, then schedules next BGAppRefreshTask with earliestBeginDate = now + 15 min +ios
(A) iOS: In App.onReceive(UIApplication.didBecomeActiveNotification) cancel all pending notifications and call NotificationScheduler.schedule(settings:) to recalibrate timing from now +ios
(A) iOS: Show full-screen SwiftUI sheet when app is active (foreground) and a break fires — sheet contains break type title, breathing animation or eye icon, CountdownRing, Snooze and Done buttons; dismiss on Snooze or Done +ios
(A) iOS: In App init check UserDefaults "hasOnboarded"; if false show onboarding as fullScreenCover +ios
(A) iOS onboarding page 1 (TabView .page style): SF Symbol "eye.fill", title, 20-20-20 explanation text, "Next" button +onboarding
(A) iOS onboarding page 2: breathing circle preview animation, micro/long break explanation, "Next" button +onboarding
(A) iOS onboarding page 3: Button "Enable Notifications" calling requestAuthorization, Toggle "Enable Eye Breaks" / "Micro Breaks" / "Long Breaks", "Get Started" button sets hasOnboarded and dismisses cover +onboarding
(A) iOS: On app open call CloudKitSyncService.sync() and SettingsSyncService.pull() to load remote settings before rendering UI +ios
(A) Implement ComplianceCalculator.streakDays(stats: [DayStat]) -> Int counting consecutive days ending today where complianceRate >= 0.8 (returns 0 if today's rate < 0.8) +stats
(A) Implement ComplianceCalculator.overallRate(stats: [DayStat]) -> Double as sum(completed) / max(sum(completed)+sum(skipped), 1) +stats
(B) macOS: Add "Pause until tomorrow" NSMenuItem that calls BreakScheduler.pause() and schedules a Timer firing at next midnight to call resume() +macos
(B) macOS: Observe NSWorkspace.didActivateApplicationNotification to re-evaluate fullscreen presentation mode detection on every app switch without polling +macos
(B) iOS: Set UNUserNotificationCenter badge count to number of breaks skipped today; clear to 0 on UIApplication.didBecomeActiveNotification +ios
(B) macOS: SettingsSyncService.observeChanges handler calls BreakScheduler.reschedule(with:) with the incoming remote settings so schedule stays in sync across devices after iCloud change +sync
(B) Write XCTest unit tests for BreakScheduler: test snooze() offsets fireDate by correct minutes, test skip() saves skipped BreakSession, test markCompleted() saves completed BreakSession +core
(B) Write XCTest unit tests for ComplianceCalculator: streakDays returns 0 for all-skipped input, returns N for N consecutive fully-compliant days, handles empty array +stats
(C) Add macOS app icon assets (1024x1024 png) and iOS app icon assets (1024x1024 png) using "eye" SF Symbol as the base design element in Assets.xcassets +macos +ios
(C) macOS StatisticsView: export stats as CSV via NSSavePanel writing date, completed, skipped columns per row +stats
(C) Identify the name of the current app, then rename it (and all its refernces in the repo) to its new name "LockOut" including in filenames
